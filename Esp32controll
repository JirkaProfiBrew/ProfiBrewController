#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Arduino.h>
#include <Nextion.h>
#include <Preferences.h>
//#include <SPIFFS.h>
#include <LittleFS.h>  // âœ… NEZAPOMEÅ‡: PÅ™idat na zaÄÃ¡tek souboru!

Preferences preferences;

// Definice prvkÅ¯ z Nextion displeje - info z ESP
NexText tTemp = NexText(2, 4, "tTemp");
NexText tPower = NexText(2, 5, "tPower");
NexText tGradient = NexText(2, 6, "tGradient");
NexText tTargetTemp = NexText(2, 10, "tTargetTemp");
NexText tTargetGrad = NexText(2, 11, "tTargetGrad");
NexText tDelayTime = NexText(2, 38, "tDelayTime");  // TextovÃ½ prvek na Nextion pro zbÃ½vajÃ­cÃ­ Äas prodlevy
NexText tUpdateInfo = NexText(2, 108, "tUpdateInfo");


// Definice prvkÅ¯ z Nextion displeje - definice hodnot pro ESP
NexNumber nTargetTemp = NexNumber(2, 20, "nTargetTemp");
NexNumber nTargetTempDec = NexNumber(2, 19, "nTargetTempDec");
NexNumber nTargetGrad = NexNumber(2, 18, "nTargetGrad");
NexNumber nDelayTime = NexNumber(2, 7, "nDelayTime");  // ÄŒÃ­selnÃ¡ hodnota prodlevy
NexNumber nPWMcycle = NexNumber(2, 99, "nPWMcycle");
NexNumber nMaxPower = NexNumber(2, 100, "nMaxPower");  // PÅ™esnÃ© ID a page dle Nextion
NexNumber nCoolRate = NexNumber(2, 98, "nCoolRate");

// Definice prvkÅ¯ z Nextion displeje - aktivnÃ­ ovlÃ¡dacÃ­ prvky
NexButton bStart = NexButton(2, 25, "bStart");
NexButton bStop = NexButton(2, 27, "bStop");
NexButton bSetTemp = NexButton(6, 4, "bSetTemp");
NexButton bSetGrad = NexButton(7, 3, "bSetGrad");
NexDSButton swAPI = NexDSButton(2, 16, "swAPI"); // Switch na strÃ¡nce 2
NexButton bSetInitValues = NexButton(3, 72, "bSetInitValues");  // UloÅ¾enÃ­ settings
NexButton bShowInit = NexButton(3, 103, "bShowInit");
NexButton bRefresh = NexButton(2, 102, "bRefresh");
NexButton bUpdateTFT = NexButton(3, 107, "bUpdateTFT");  // PÅ™esnÃ¡ strÃ¡nka a ID Nextion tlaÄÃ­tka


// Pole s prvky pro nexLoop()
NexTouch *nex_listen_list[] = {
    &tTemp,
    &tPower,
    &tGradient,
    &tTargetTemp,
    &tTargetGrad,
    &tDelayTime,
    &nTargetTemp, 
    &nTargetTempDec,
    &nTargetGrad,
    &nDelayTime,
    &bStart,
    &bStop,
    &bSetTemp,
    &bSetGrad,
    &swAPI,
    &nPWMcycle,
    &bSetInitValues,
    &nMaxPower,
    &nCoolRate,
    &bShowInit,
    &bRefresh,
    &bUpdateTFT,

    NULL  // UkonÄenÃ­ pole
};

const char* ssid = "PancakoviV";
const char* password = "8060180568Jp";
//const char* ssid = "Xiaomi 13T Pro";
//const char* password = "xsle4984";
const char* tftUpdateUrl = "https://github.com/JirkaProfiBrew/Nextion/raw/refs/heads/main/ProfiBrewController.tft"; // link github
const char* tftVersionUrl = "https://github.com/JirkaProfiBrew/Nextion/raw/refs/heads/main/version.txt";       // MalÃ½ txt se verzÃ­
const char* localTFTVersion = "1.0";  // LokÃ¡lnÃ­ verze TFT


// ğŸ“¡ API endpointy v Bubble
const char* bubbleGetAPI = "https://panecto.com/version-test/api/1.1/obj/controller_command/1739630768554x789594921163105700";
const char* bubblePostAPI = "https://panecto.com/version-test/api/1.1/wf/get_heater_status";


#define HEATER_PIN 5  // GPIO pro topenÃ­
#define GREEN_LED 4  // GPIO pro zelenou LED (topenÃ­ zapnutÃ©)
#define RED_LED 5  // GPIO pro Äervenou LED (topenÃ­ vypnutÃ©)
//#define PWM_CYCLE_MS 10000  // Jeden PWM cyklus = 10 sekund
//#define MAX_HEAT_RATE 0.2  // MaximÃ¡lnÃ­ nÃ¡rÅ¯st teploty pÅ™i 100 % vÃ½konu
//#define COOL_RATE 0.1       // Rychlost poklesu pÅ™i vypnutÃ©m ohÅ™evu
#define POWER_ADJUST_STEP 5  // Krok Ãºpravy vÃ½konu v %
#define NEXTION_SERIAL Serial2  // ESP32 pouÅ¾Ã­vÃ¡ UART2

// PromÄ›nnÃ© pro Preferences
int PWM_CYCLE_MS = 10000; //vÃ½chozÃ­ hodnota
float MAX_HEAT_RATE = 0.2;
float COOL_RATE = 0.1;


bool heatingActive = false;  // Å˜Ã­dÃ­, zda mÃ¡ bÃ½t ohÅ™ev aktivnÃ­
bool lastPwmState = false; // ğŸ†• PoslednÃ­ znÃ¡mÃ½ stav pwmState


// ÄŒasovaÄe pro jednotlivÃ© Ãºlohy
unsigned long lastGradientUpdate = 0;
unsigned long lastPowerAdjustment = 0; // ÄŒas poslednÃ­ Ãºpravy vÃ½konu
unsigned long delayStartTime = 0;  // ÄŒas spuÅ¡tÄ›nÃ­ prodlevy
int remainingDelayTime = 0;  // ZbÃ½vajÃ­cÃ­ Äas do konce prodlevy (v sekundÃ¡ch)
unsigned long lastLEDUpdate = 0;
unsigned long lastNextionUpdate = 0;
unsigned long lastAPIUpdate = 0;


// ÄŒasovÃ© intervaly pro jednotlivÃ© Ãºlohy
const unsigned long GRADIENT_UPDATE_INTERVAL = 5000;  // 5 sekund - vÃ½poÄet gradientu
const unsigned long POWER_ADJUST_INTERVAL = 30000;    // 30 sekund - korekce vÃ½konu
const unsigned long LED_UPDATE_INTERVAL = 1000;       // 1 sekunda - aktualizace LED
const unsigned long NEXTION_UPDATE_INTERVAL = 5000;   // 5 sekund - aktualizace displeje
const unsigned long API_UPDATE_INTERVAL = 5000;       // 5 sekund - odesÃ­lÃ¡nÃ­ dat do API
const unsigned long DELAY_INTERVAL = 60000;  // 1 minuta v milisekundÃ¡ch

bool heaterState = false;
bool delayActive = false;  // Indikuje, zda probÃ­hÃ¡ prodleva
bool apiEnabled = false;  // VÃ½chozÃ­ stav: API komunikace nepovolena
float currentTemperature = 22.0;  
float targetTemperature = 28.0;   
float hysteresis = 0.5;           
float temperatureGradient = 0.0;
float targetGradient = 0.5;  // PoÅ¾adovanÃ½ gradient Â°C/min
int heaterPower = 100;  // VÃ½chozÃ­ vÃ½kon v %

unsigned long cycleStartTime = 0;
bool pwmState = false;  // Stav topenÃ­ v rÃ¡mci PWM cyklu

// ğŸ“Š **CyklickÃ½ buffer pro teploty z poslednÃ­ch 2 minut**
const int TEMP_HISTORY_SIZE = 24;  // 2 minuty (120 sekund) / 5 sec = 24 vzorkÅ¯
float tempHistory[TEMP_HISTORY_SIZE] = {0};  // Pole pro uklÃ¡dÃ¡nÃ­ teplot
int tempIndex = 0;  // AktuÃ¡lnÃ­ pozice v bufferu
bool bufferFilled = false;  // Kontroluje, zda uÅ¾ mÃ¡me dost dat pro vÃ½poÄet gradientu

void setup() {
    Serial.begin(115200);
    NEXTION_SERIAL.begin(115200, SERIAL_8N1, 16, 17);  // RX=16, TX=17 pro ESP32
    nexInit();  // Inicializace Nextion displeje
    Serial.println("âœ… Nextion displej pÅ™ipojen!");
    
    // PÅ™ipojenÃ­ callback funkcÃ­ pro tlaÄÃ­tka
    bStart.attachPop(bStartPressCallback);
    bStop.attachPop(bStopPressCallback);
    bSetTemp.attachPop(bSetTempCallback);
    bSetGrad.attachPop(bSetGradientCallback);
    swAPI.attachPop(swAPICallback);
    bSetInitValues.attachPop(bSetInitValuesCallback); 
    bShowInit.attachPop(bShowInitCallback);
    bRefresh.attachPop(bRefreshCallback);
    bUpdateTFT.attachPop(bUpdateTFTCallback);

    Serial.println("âœ… Nextion tlaÄÃ­tka pÅ™ipojena!");
  
    //heaterPower = 100;  // Na zaÄÃ¡tku ohÅ™ev vÅ¾dy na 100 %
    pinMode(HEATER_PIN, OUTPUT);
    pinMode(GREEN_LED, OUTPUT);
    pinMode(RED_LED, OUTPUT);
    digitalWrite(HEATER_PIN, LOW);
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(RED_LED, LOW);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nâœ… WiFi pÅ™ipojeno!");

    loadSettings();  // NaÄti hodnoty z pamÄ›ti pÅ™i startu

    if (!LittleFS.begin(true)) {
    Serial.println("âŒ Chyba pÅ™i inicializaci LittleFS!");
    }


    nMaxPower.setValue((int)(MAX_HEAT_RATE * 10));


  // ğŸ†• Aktualizace displeje hned po spuÅ¡tÄ›nÃ­
    updateNextionDisplay();
    Serial.println("âœ… Displej Nextion inicializovÃ¡n s aktuÃ¡lnÃ­mi hodnotami.");
}

String formatTime(int seconds) {
    int hours = seconds / 3600;
    int minutes = (seconds % 3600) / 60;
    int secs = seconds % 60;
    
    char timeStr[10];  // Buffer pro formÃ¡tovanÃ½ Å™etÄ›zec
    
    if (hours > 0) {
        snprintf(timeStr, sizeof(timeStr), "%02d:%02d:%02d", hours, minutes, secs); // hh:mm:ss
    } else {
        snprintf(timeStr, sizeof(timeStr), "%02d:%02d", minutes, secs); // mm:ss
    }

    return String(timeStr);
}

bool safeGetValue(NexNumber &nexNum, uint32_t *value) {
    bool success = false;
    for (int i = 0; i < 3; i++) {
        success = nexNum.getValue(value);
        if (success) break;
        delay(50);
    }
    return success;
}

void loadSettings() {
    preferences.begin("heater", true);
    PWM_CYCLE_MS = preferences.getInt("PWM_CYCLE_MS", 10000);  // NaÄtenÃ­ hodnoty, vÃ½chozÃ­ = 10000
    MAX_HEAT_RATE = preferences.getFloat("MAX_HEAT_RATE", 0.2);
    COOL_RATE = preferences.getFloat("COOL_RATE", 0.1);

    preferences.end();
}

void saveSettings() {
    preferences.begin("heater", false);
    preferences.putInt("PWM_CYCLE_MS", PWM_CYCLE_MS);
    preferences.putFloat("MAX_HEAT_RATE", MAX_HEAT_RATE);
    preferences.putFloat("COOL_RATE", COOL_RATE);
    preferences.end();
}

void loadInitValuesFromNextion() {
    Serial.println("ğŸ“¥ NaÄÃ­tÃ¡nÃ­ hodnot z Nextion...");

   delay(300);  // UmoÅ¾nÃ­ Nextionu naÄÃ­st strÃ¡nku s hodnotami

    uint32_t pwmCycleValue = 0;
    uint32_t maxRateRaw = 0;
    uint32_t coolRateRaw = 0;

    bool ok1 = false, ok2 = false, ok3 = false;
for (int i = 0; i < 3; i++) {
    if (!ok1) ok1 = nPWMcycle.getValue(&pwmCycleValue);
    if (!ok2) ok2 = nMaxPower.getValue(&maxRateRaw);
    if (!ok3) ok3 = nCoolRate.getValue(&coolRateRaw);
    if (ok1 && ok2 && ok3) break;
    delay(50);
}


    if (!ok1) {
        Serial.println("âš ï¸ Nelze naÄÃ­st nPWMcycle z Nextion!");
    } else {
        PWM_CYCLE_MS = pwmCycleValue * 1000;
        Serial.print("âœ… PWM_CYCLE_MS: "); Serial.println(PWM_CYCLE_MS);
    }

    if (!ok2) {
        Serial.println("âš ï¸ Nelze naÄÃ­st nMaxPower z Nextion!");
    } else {
        MAX_HEAT_RATE = maxRateRaw / 10.0;
        Serial.print("âœ… MAX_HEAT_RATE: "); Serial.println(MAX_HEAT_RATE);
    }

    if (!ok3) {
        Serial.println("âš ï¸ Nelze naÄÃ­st nCoolRate z Nextion!");
    } else {
        COOL_RATE = coolRateRaw / 10.0;
        Serial.print("âœ… COOL_RATE: "); Serial.println(COOL_RATE);
    }
}

void updateInitValuesOnNextion() {
    nPWMcycle.setValue(PWM_CYCLE_MS / 1000);
    nMaxPower.setValue((int)(MAX_HEAT_RATE * 10));
    nCoolRate.setValue((int)(COOL_RATE * 10));

}

void startHeating() {
    Serial.println("ğŸ”¥ START: OhÅ™ev zapnut!");
    heatingActive = true;  // Aktivujeme ohÅ™ev
    heaterPower = 100;  // Po spuÅ¡tÄ›nÃ­ nastavÃ­me vÃ½kon na 100%
    cycleStartTime = millis();  // Resetujeme Äas PWM cyklu
    lastGradientUpdate = millis();
    lastPowerAdjustment = millis();
    lastLEDUpdate = millis();
    lastNextionUpdate = millis();
    lastAPIUpdate = millis();

  // OkamÅ¾itÃ¡ aktualizace displeje Nextion
    updateNextionDisplay();
}

void stopHeating() {
    Serial.println("ğŸ›‘ STOP: OhÅ™ev vypnut a ÄÃ­taÄe vynulovÃ¡ny.");
    heatingActive = false;  // Deaktivujeme ohÅ™ev
    heaterPower = 0;        // NastavenÃ­ vÃ½konu na 0 %
    heaterState = false;
    cycleStartTime = 0;
    digitalWrite(HEATER_PIN, LOW); // Fyzicky vypneme ohÅ™ev

    // VynulovÃ¡nÃ­ gradientu a reset bufferu
    temperatureGradient = 0.0;
    bufferFilled = false;
    tempIndex = 0;
    for (int i = 0; i < TEMP_HISTORY_SIZE; i++) {
        tempHistory[i] = 0;
    }

    // **ğŸ†• Reset prodlevy**
    delayActive = false;
    remainingDelayTime = 0;
    Serial.println("ğŸ•’ Prodleva vynulovÃ¡na.");

    // OkamÅ¾itÃ¡ aktualizace displeje Nextion
    updateNextionDisplay();

    Serial.println("âš¡ VÃ½kon nastaven na 0% | Gradient resetovÃ¡n");
}

void bSetInitValuesCallback(void *ptr) {
    Serial.println("ğŸŸ¢ NastavenÃ­ inicializaÄnÃ­ch hodnot...");

    // PÅ™epneme na strÃ¡nku Hand (page 2)
    Serial2.print("page 2");
    Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    delay(500);  // NechÃ¡me naÄÃ­st strÃ¡nku

    uint32_t pwmCycleVal = 0;
    uint32_t maxRateVal = 0;
    uint32_t coolRateVal = 0;

    bool ok1 = safeGetValue(nPWMcycle, &pwmCycleVal);
    bool ok2 = safeGetValue(nMaxPower, &maxRateVal);
    bool ok3 = safeGetValue(nCoolRate, &coolRateVal);

    if (!ok1) Serial.println("âŒ Chyba: nPWMcycle se nepodaÅ™ilo naÄÃ­st.");
    if (!ok2) Serial.println("âŒ Chyba: nMaxPower se nepodaÅ™ilo naÄÃ­st.");
    if (!ok3) Serial.println("âŒ Chyba: nCoolRate se nepodaÅ™ilo naÄÃ­st.");

    Serial.print("ğŸ“‹ NaÄtenÃ© hodnoty z Hand: PWM = ");
    Serial.print(pwmCycleVal);
    Serial.print(", MaxPower = ");
    Serial.print(maxRateVal);
    Serial.print(", CoolRate = ");
    Serial.println(coolRateVal);

    if (!ok1 || !ok2 || !ok3) {
        Serial.println("âŒ Nelze naÄÃ­st jednu nebo vÃ­ce hodnot z Nextion (Hand strÃ¡nka).");
        return;
    }

    // Aktualizace hodnot v pamÄ›ti
    PWM_CYCLE_MS = pwmCycleVal * 1000;
    MAX_HEAT_RATE = maxRateVal / 10.0;
    COOL_RATE = coolRateVal / 10.0;

    saveSettings();              // UloÅ¾Ã­me zmÄ›ny do Preferences
    updateInitValuesOnNextion();  // Aktualizujeme displej pro jistotu

    Serial.println("âœ… InicializaÄnÃ­ hodnoty uloÅ¾eny a zobrazeny.");
}

void bShowInitCallback(void *ptr) {
    Serial.println("ğŸ“Ÿ PoÅ¾adavek na zobrazenÃ­ init hodnot z Preferences");
    loadSettings();
    updateInitValuesOnNextion();
}

void bUpdateTFTCallback(void *ptr) {
    Serial.println("ğŸ”„ Stisknuto tlaÄÃ­tko Aktualizace TFT");
    updateNextionTFT();
}

void bRefreshCallback(void *ptr) {
    Serial.println("ğŸ”„ bRefreshCallback - aktualizace Nextion displeje");
    updateNextionDisplay();
}

void bStartPressCallback(void *ptr) {
    Serial.println("ğŸŸ¢ Stisknuto tlaÄÃ­tko START");
    startHeating();
}

void bStopPressCallback(void *ptr) {
    Serial.println("ğŸ”´ Stisknuto tlaÄÃ­tko STOP");
    stopHeating();
}

void bSetTempCallback(void *ptr) {
    Serial.println("ğŸ“¡ Pokus o naÄtenÃ­ teploty z Nextionu...");

    uint32_t wholePart = 0, decimalPart = 0;
    bool ok1 = safeGetValue(nTargetTemp, &wholePart);
    bool ok2 = safeGetValue(nTargetTempDec, &decimalPart);

    if (!ok1 || !ok2) {
        Serial.println("âŒ Chyba pÅ™i ÄtenÃ­ teploty z Nextion displeje!");
        return;
    }

    targetTemperature = wholePart + (decimalPart / 10.0);

    Serial.print("ğŸ¯ NastavenÃ¡ cÃ­lovÃ¡ teplota: ");
    Serial.println(targetTemperature);

    updateNextionDisplay();

    if (apiEnabled) {
        sendHeaterStatus();
    }
}

void bSetGradientCallback(void *ptr) {
    Serial.println("ğŸ“¡ Pokus o naÄtenÃ­ gradientu z Nextionu...");

    uint32_t gradientValue = 0;
    bool ok = safeGetValue(nTargetGrad, &gradientValue);

    if (!ok) {
        Serial.println("âŒ Chyba pÅ™i ÄtenÃ­ gradientu z Nextion displeje!");
        return;
    }

    targetGradient = gradientValue / 10.0;

    Serial.print("ğŸ“Š NastavenÃ½ poÅ¾adovanÃ½ gradient: ");
    Serial.println(targetGradient);

    //updateNextionDisplay();

    if (apiEnabled) {
        sendHeaterStatus();
    }
}

void swAPICallback(void *ptr) {
    uint32_t state;
    swAPI.getValue(&state);  // NaÄteme stav switche (0 = vypnuto, 1 = zapnuto)

    if (state == 1) {
        apiEnabled = true;
        Serial.println("âœ… API komunikace zapnuta.");
    } else {
        apiEnabled = false;
        Serial.println("âŒ API komunikace vypnuta.");
    }
}

void updateTemperature() {
    if (heaterPower > 0) {
        currentTemperature += (heaterPower / 100.0) * MAX_HEAT_RATE;
    } else {
        currentTemperature -= COOL_RATE;
    }
    Serial.print("ğŸŒ¡ AktuÃ¡lnÃ­ teplota: ");
    Serial.print(currentTemperature);
    Serial.println(" Â°C");

   // ğŸ”¥ OkamÅ¾itÃ© zahÃ¡jenÃ­ prodlevy pÅ™i dosaÅ¾enÃ­ teploty
    if (currentTemperature >= targetTemperature && !delayActive) {
        Serial.println("ğŸ¯ CÃ­lovÃ¡ teplota dosaÅ¾ena, zahajuji prodlevu.");
        startDelay();
    }
}

void calculateTemperatureGradient() {
    tempHistory[tempIndex] = currentTemperature;
    int oldIndex = (tempIndex + 1) % TEMP_HISTORY_SIZE;
    
    if (!bufferFilled && oldIndex == 0) {
        bufferFilled = true;
    }

    if (bufferFilled) {
        float oldTemperature = tempHistory[oldIndex];  
        temperatureGradient = (currentTemperature - oldTemperature) / 2.0;  // Â°C/min

        Serial.print("ğŸ“Š Gradient ohÅ™evu: ");
        Serial.print(temperatureGradient);
        Serial.print(" Â°C/min | ğŸ¯ PoÅ¾adovanÃ½ gradient: ");
        Serial.println(targetGradient);
    } else {
        Serial.println("â³ ÄŒekÃ¡m na dostatek dat pro vÃ½poÄet gradientu...");
    }

    tempIndex = (tempIndex + 1) % TEMP_HISTORY_SIZE;
}

void adjustHeaterPower() {
    
    if (!bufferFilled) {
        Serial.println("âš ï¸ Gradient nenÃ­ znÃ¡m, vÃ½kon ponechÃ¡n na 100 %");
        heaterPower = 100;  // Na zaÄÃ¡tku ohÅ™Ã­vÃ¡me naplno
        return;
    }

    float gradientDifference = targetGradient - temperatureGradient;
    float adjustment = gradientDifference * 15;  // ZvÃ½Å¡enÃ½ koeficient pro rychlejÅ¡Ã­ pÅ™izpÅ¯sobenÃ­

    heaterPower += constrain(adjustment, -POWER_ADJUST_STEP * 2, POWER_ADJUST_STEP * 2);
    heaterPower = constrain(heaterPower, 0, 100);

    Serial.print("âš¡ UpravenÃ½ vÃ½kon: ");
    Serial.print(heaterPower);
    Serial.println(" %");

}

void controlHeaterPWM() {
    unsigned long elapsedTime = millis() - cycleStartTime;
    unsigned long onTime = (PWM_CYCLE_MS * heaterPower) / 100;
    
    if (heaterPower == 0) {
        pwmState = false;
    } else if (heaterPower == 100) {
        pwmState = true;
    } else {
        pwmState = (elapsedTime < onTime);
        if (elapsedTime >= PWM_CYCLE_MS) {
            cycleStartTime = millis();
        }
    }

    digitalWrite(HEATER_PIN, pwmState ? HIGH : LOW);
    heaterState = (heaterPower > 0);

  // ğŸ†• Aktualizace barvy tlaÄÃ­tka bPowerSignal POUZE pÅ™i zmÄ›nÄ› pwmState
    if (pwmState != lastPwmState) {
    if (pwmState) {
        Serial2.print("bPowerSignal.bco=2016");
    } else {
        Serial2.print("bPowerSignal.bco=63488");
    }
    Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    
    lastPwmState = pwmState;  // Aktualizuj uloÅ¾enÃ½ stav
    }
}

void startDelay() {
    delayActive = true;
    delayStartTime = millis();
    
    uint32_t delayValue = 0; // PromÄ›nnÃ¡ pro uloÅ¾enÃ­ hodnoty prodlevy
    bool success = false;
    for (int i = 0; i < 3; i++) {  
        success = nDelayTime.getValue(&delayValue);  
        if (success) break;  
        delay(50);  
    }
    if (!success) {
        Serial.println("âŒ Chyba pÅ™i ÄtenÃ­ hodnoty prodlevy z Nextion displeje!");
        return;
    }

    remainingDelayTime = delayValue * 60; // PÅ™evod na sekundy
    heaterPower = 0;  // VypnutÃ­ ohÅ™evu

    Serial.print("ğŸ•’ Prodleva spuÅ¡tÄ›na na: ");
    Serial.print(remainingDelayTime / 60);
    Serial.println(" minut.");

    // ğŸ”„ OkamÅ¾itÃ¡ aktualizace displeje Nextion
    String delayCmd = "tDelayTime.txt=\"" + String(remainingDelayTime) + "s\"";
    Serial2.print(delayCmd); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
}

void controlLED() {
    if (heaterPower > 0) {
        digitalWrite(GREEN_LED, pwmState ? LOW : HIGH);
        digitalWrite(RED_LED, pwmState ? HIGH : LOW);
    } else {
        digitalWrite(GREEN_LED, HIGH);
        digitalWrite(RED_LED, HIGH);
    }
}

void updateNextionDisplay() {
    String cmdTemp = "tTemp.txt=\"" + String(currentTemperature) + "\"";
    String cmdPower = "tPower.txt=\"" + String(heaterPower) + " %\"";
    String cmdGradient = "tGradient.txt=\"" + String(temperatureGradient) + "\"";
    String cmdTargetTemp = "tTargetTemp.txt=\"" + String(targetTemperature, 1) + "\"";
    String cmdTargetGrad = "tTargetGrad.txt=\"" + String(targetGradient, 1) + "\"";

    Serial2.print(cmdTemp); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    Serial2.print(cmdPower); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    Serial2.print(cmdGradient); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    Serial2.print(cmdTargetTemp); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    Serial2.print(cmdTargetGrad); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);

    Serial.print("ğŸŒ¡ Teplota: ");
    Serial.print(currentTemperature);
    Serial.print(" Â°C | ğŸ¯ CÃ­l: ");
    Serial.print(targetTemperature);
    Serial.print(" Â°C | ğŸ”¥ Stav: ");
    Serial.print(heaterState ? "ON" : "OFF");
    Serial.print(" | âš¡ VÃ½kon: ");
    Serial.print(heaterPower);
    Serial.print(" % | ğŸ“Š Gradient: ");
    Serial.print(temperatureGradient);
    Serial.print(" Â°C/min | PoÅ¾. gradient: ");
    Serial.print(targetGradient);
    Serial.println(" Â°C/min");
    Serial.print(" | MAX_HEAT_RATE: "); Serial.print(MAX_HEAT_RATE);
    Serial.print(" | COOL_RATE: "); Serial.println(COOL_RATE);
    Serial.print(" | PWM Stav: ");
    Serial.println(pwmState ? "ON" : "OFF");
    


}

void resetNextionAfterError() {
    Serial.println("ğŸ” Resetuji Nextion po chybÄ›...");
    Serial2.print("rest");
    Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    delay(1000); // Pauza pro stabilizaci
}

bool downloadTFTFile(const char* url, const char* savePath) {
  Serial.println("ğŸ“¥ Zahajuji stahovÃ¡nÃ­ TFT souboru pÅ™es LittleFS...");

  if (!LittleFS.begin(true)) {
    Serial.println("âŒ LittleFS inicializace selhala!");
    return false;
  }

  // ğŸ§¹ Nejprve SMAZAT pÅ¯vodnÃ­ soubor
  if (LittleFS.exists(savePath)) {
    Serial.println("ğŸ“‚ ExistujÃ­cÃ­ soubor nalezen, odstraÅˆuji...");
    if (LittleFS.remove(savePath)) {
      Serial.println("âœ… Soubor odstranÄ›n.");
    } else {
      Serial.println("âŒ NepodaÅ™ilo se odstranit soubor!");
      return false;
    }
  } else {
    Serial.println("ğŸ“‚ PÅ¯vodnÃ­ soubor neexistoval.");
  }

  // ğŸ§® PotÃ© zjistit novÃ© volnÃ© mÃ­sto
  size_t totalBytes = LittleFS.totalBytes();
  size_t usedBytes = LittleFS.usedBytes();
  size_t freeSpace = totalBytes - usedBytes;

  Serial.print("ğŸ“¦ CelkovÃ½ prostor: "); Serial.println(totalBytes);
  Serial.print("ğŸ“¦ VyuÅ¾ito: "); Serial.println(usedBytes);
  Serial.print("ğŸ“¦ VolnÃ© mÃ­sto: "); Serial.println(freeSpace);

  // ğŸŒ PÅ™ipojit k serveru
  HTTPClient http;
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  http.begin(url);
  int httpCode = http.GET();

  if (httpCode != HTTP_CODE_OK) {
    Serial.print("âŒ HTTP chyba: "); Serial.println(httpCode);
    http.end();
    return false;
  }

  int totalSize = http.getSize();
  Serial.print("ğŸ“„ Velikost souboru ke staÅ¾enÃ­: "); Serial.println(totalSize);

  if (totalSize > freeSpace) {
    Serial.println("âŒ Nedostatek mÃ­sta v LittleFS!");
    http.end();
    return false;
  }

  File tftFile = LittleFS.open(savePath, "w");
  if (!tftFile) {
    Serial.println("âŒ Nelze otevÅ™Ã­t soubor pro zÃ¡pis!");
    http.end();
    return false;
  }

  WiFiClient* stream = http.getStreamPtr();
  uint8_t buffer[1024];
  int bytesDownloaded = 0;
  int lastPercentReported = 0;
  unsigned long lastWriteTime = millis();

  Serial.println("ğŸ“¥ Zahajeno stahovÃ¡nÃ­ souboru...");

  while (http.connected() && bytesDownloaded < totalSize) {
    size_t available = stream->available();
    if (available) {
      int bytesToRead = min(available, (size_t)1024);
      int bytesRead = stream->readBytes(buffer, bytesToRead);

      size_t bytesWritten = tftFile.write(buffer, bytesRead);
      if (bytesWritten != bytesRead) {
        Serial.println("âŒ Chyba pÅ™i zÃ¡pisu do souboru!");
        tftFile.close();
        http.end();
        return false;
      }

      bytesDownloaded += bytesRead;

      if (millis() - lastWriteTime > 1000) {
        tftFile.flush();
        lastWriteTime = millis();
      }

      int percent = (bytesDownloaded * 100) / totalSize;
      if (percent >= lastPercentReported + 10 || bytesDownloaded == totalSize) {
        lastPercentReported = percent;
        Serial.print("âœ… StaÅ¾eno: "); Serial.print(percent); Serial.println("%");
      }
    }
    yield();
  }

  tftFile.flush();
  tftFile.close();
  http.end();

  // ğŸ“‹ OvÄ›Å™enÃ­ souboru
  File checkFile = LittleFS.open(savePath, "r");
  if (!checkFile) {
    Serial.println("âŒ Nelze ovÄ›Å™it soubor po staÅ¾enÃ­!");
    return false;
  }
  size_t fileSize = checkFile.size();
  checkFile.close();

  Serial.print("ğŸ“¦ Velikost uloÅ¾enÃ©ho souboru: ");
  Serial.println(fileSize);

  if (fileSize > 0 && (fileSize >= totalSize * 0.9)) {
    Serial.println("ğŸ‰ Soubor staÅ¾en a uloÅ¾en ÃºspÄ›Å¡nÄ›!");
    return true;
  } else {
    Serial.println("âŒ StaÅ¾enÃ½ soubor nesedÃ­ velikostÃ­!");
    return false;
  }
}

void updateNextionTFT() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("âŒ WiFi nenÃ­ pÅ™ipojeno!");
        resetNextionAfterError();
        return;
    }

    HTTPClient http;
    http.begin(tftVersionUrl);
    int httpResponseCode = http.GET();

    if (httpResponseCode <= 0) {
        Serial.println("âŒ Chyba pÅ™i naÄÃ­tÃ¡nÃ­ verze!");
        http.end();
        resetNextionAfterError();
        return;
    }

    String serverVersion = http.getString();
    serverVersion.trim();
    Serial.print("ğŸ” Verze na serveru: "); Serial.println(serverVersion);

    if (serverVersion == localTFTVersion) {
        Serial.println("â„¹ï¸ TFT je aktuÃ¡lnÃ­, nenÃ­ potÅ™eba aktualizovat.");
        http.end();
        return;
    }

    http.end();

    if (!downloadTFTFile(tftUpdateUrl, "/update.tft")) {
        Serial.println("âŒ StaÅ¾enÃ­ souboru selhalo!");
        resetNextionAfterError();
        return;
    }

    File tftFile = LittleFS.open("/update.tft", FILE_READ);
    if (!tftFile) {
        Serial.println("âŒ Chyba pÅ™i otevÅ™enÃ­ staÅ¾enÃ©ho souboru!");
        resetNextionAfterError();
        return;
    }

    size_t fileSize = tftFile.size();
    Serial.print("ğŸ“¦ Velikost souboru: ");
    Serial.println(fileSize);

    // PÅ™epnutÃ­ Nextionu do reÅ¾imu aktualizace
    Serial.println("ğŸ“¡ PÅ™epÃ­nÃ¡m Nextion do reÅ¾imu aktualizace...");
    Serial2.print("whmi-wri ");
    Serial2.print(fileSize);
    Serial2.print(",115200,0");
    Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);

    delay(3000);  // ğŸ›  PÅ™idÃ¡no ÄekÃ¡nÃ­ 3 sekundy! Velmi dÅ¯leÅ¾itÃ© pro stabilitu.
  
    unsigned long startWait = millis();
    bool ready = false;
    while (millis() - startWait < 5000) {
        if (Serial2.available()) {
            uint8_t b = Serial2.read();
            if (b == 0x05) {  // Ready
                ready = true;
                break;
            }
        }
        delay(10);
    }

    if (!ready) {
        Serial.println("âŒ Nextion neodpovÄ›dÄ›l (0x05) - aktualizace zruÅ¡ena");
        tftFile.close();
        resetNextionAfterError();
        return;
    }

    // OdesÃ­lÃ¡nÃ­ souboru
    Serial.println("ğŸ“¤ PosÃ­lÃ¡m soubor do Nextion...");
    uint8_t buf[512];
    size_t bytesSent = 0;

    while (tftFile.available()) {
        size_t bytesRead = tftFile.readBytes((char*)buf, sizeof(buf));
        Serial2.write(buf, bytesRead);
        bytesSent += bytesRead;

        if (bytesSent % 10240 < sizeof(buf)) {
            Serial.print("OdeslÃ¡no: ");
            Serial.print(bytesSent);
            Serial.print(" / ");
            Serial.println(fileSize);
        }

        delay(5);
    }

    tftFile.close();
    Serial.println("âœ… OdesÃ­lÃ¡nÃ­ dokonÄeno, ÄekÃ¡m na potvrzenÃ­...");

    // ÄŒekÃ¡nÃ­ na ÃºspÄ›ch (0x05)
    startWait = millis();
    bool success = false;
    while (millis() - startWait < 20000) {
        if (Serial2.available()) {
            uint8_t b = Serial2.read();
            if (b == 0x05) {  // Success
                success = true;
                break;
            }
        }
        delay(10);
    }

    if (success) {
        Serial.println("ğŸ‰ Aktualizace TFT probÄ›hla ÃºspÄ›Å¡nÄ›!");
    } else {
        Serial.println("âŒ Aktualizace se nezdaÅ™ila!");
        resetNextionAfterError();
    }
}


void getControlData() {
    if (WiFi.status() != WL_CONNECTED) return;

    HTTPClient http;
    http.begin(bubbleGetAPI);
    int httpResponseCode = http.GET();

    if (httpResponseCode > 0) {
        String response = http.getString();
        Serial.print("ğŸ“¥ OdpovÄ›Ä z Bubble: ");
        Serial.println(response);

        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, response);

        if (!error) {
            if (doc.containsKey("response")) {
                JsonObject resp = doc["response"];
                
                if (resp.containsKey("target_temperature")) {
                    float newTemp = resp["target_temperature"];
                    if (newTemp != targetTemperature) {
                        targetTemperature = newTemp;
                        Serial.print("ğŸ”„ Aktualizace cÃ­lovÃ© teploty z API: ");
                        Serial.println(targetTemperature);
                        updateNextionDisplay();
                    }
                }

                if (resp.containsKey("target_gradient")) {
                    float newGrad = resp["target_gradient"];
                    if (newGrad != targetGradient) {
                        targetGradient = newGrad;
                        Serial.print("ğŸ”„ Aktualizace poÅ¾adovanÃ©ho gradientu z API: ");
                        Serial.println(targetGradient);
                        updateNextionDisplay();
                    }
                }
            }
        }
    }
    http.end();
}

void sendHeaterStatus() {
    if (WiFi.status() != WL_CONNECTED) return;

    HTTPClient http;
    http.begin(bubblePostAPI);
    http.addHeader("Content-Type", "application/json");

    String jsonData;
    StaticJsonDocument<256> doc;
    doc["heater"] = heaterState;
    doc["current_temperature"] = currentTemperature;
    doc["target_temperature"] = targetTemperature;
    doc["temperature_gradient"] = temperatureGradient;
    doc["heater_power"] = heaterPower;

    serializeJson(doc, jsonData);
    http.POST(jsonData);
    http.end();
}

void loop() {
    unsigned long currentMillis = millis();

  // NaslouchÃ¡nÃ­ udÃ¡lostem z Nextionu
    nexLoop(nex_listen_list); 
    
    
    if (heatingActive) { // KÃ³d se spustÃ­ jen pokud je aktivnÃ­ ohÅ™ev
        // ğŸ“Š VyhodnocenÃ­ gradientu kaÅ¾dÃ½ch 5 sekund
        if (currentMillis - lastGradientUpdate >= GRADIENT_UPDATE_INTERVAL) {
            calculateTemperatureGradient();
            lastGradientUpdate = currentMillis;
        }

        // ğŸ”¥ Korekce vÃ½konu podle gradientu kaÅ¾dÃ½ch 30 sekund
        if (currentMillis - lastPowerAdjustment >= POWER_ADJUST_INTERVAL) {
            adjustHeaterPower();
            lastPowerAdjustment = currentMillis;
        }

        // ğŸ’¡ Aktualizace LED kaÅ¾dou sekundu
        if (currentMillis - lastLEDUpdate >= LED_UPDATE_INTERVAL) {
            controlLED();
            lastLEDUpdate = currentMillis;
        }

     if (delayActive) {
    unsigned long elapsedDelay = (millis() - delayStartTime) / 1000;  // Doba od spuÅ¡tÄ›nÃ­ v sekundÃ¡ch

    uint32_t delayValue = 0; // PromÄ›nnÃ¡ pro uloÅ¾enÃ­ hodnoty prodlevy
    bool success = nDelayTime.getValue(&delayValue);  // NaÄtenÃ­ prodlevy v minutÃ¡ch

    if (!success) {
        Serial.println("âŒ Chyba pÅ™i ÄtenÃ­ hodnoty prodlevy z Nextion displeje!");
        return;
    }

    remainingDelayTime = (delayValue * 60) - elapsedDelay;

    if (remainingDelayTime <= 0) {
        delayActive = false;
        Serial.println("âœ… Prodleva skonÄila, pÅ™epÃ­nÃ¡m na strÃ¡nku pStepEnd.");
        
        // PÅ™epnutÃ­ na strÃ¡nku s ukonÄenÃ­m kroku
        Serial2.print("page 9"); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);

        // **ğŸ†• SpuÅ¡tÄ›nÃ­ stopHeating()**
        stopHeating();
    } else {
        // ğŸ”¹ **PouÅ¾itÃ­ novÃ© funkce formatTime()**
        String formattedTime = formatTime(remainingDelayTime);

        Serial.print("ğŸ•’ ZbÃ½vajÃ­cÃ­ Äas prodlevy: ");
        Serial.println(formattedTime);

        String delayCmd = "tDelayTime.txt=\"" + formattedTime + "\"";
        Serial2.print(delayCmd); Serial2.write(0xFF); Serial2.write(0xFF); Serial2.write(0xFF);
    }
}


        // ğŸ”„ Aktualizace teploty a displeje Nextion kaÅ¾dÃ½ch 5 sekund
        if (currentMillis - lastNextionUpdate >= NEXTION_UPDATE_INTERVAL) {
            updateTemperature();
            updateNextionDisplay();
            lastNextionUpdate = currentMillis;
        }

        // ğŸ“¡ ZÃ­skÃ¡vÃ¡nÃ­ dat z API kaÅ¾dÃ½ch 5 sekund
        if (apiEnabled && currentMillis - lastAPIUpdate >= API_UPDATE_INTERVAL) {
        getControlData();
        sendHeaterStatus();
        lastAPIUpdate = currentMillis;
        }

        // ğŸ”¥ Å˜Ã­zenÃ­ ohÅ™evu (PWM cyklus bÄ›Å¾Ã­ nezÃ¡visle)
        controlHeaterPWM();
    }
}
